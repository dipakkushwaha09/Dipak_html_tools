<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF PowerSuite - Enhanced Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>

    <style>
        :root {
            --primary-color: #007BA7; /* Cerulean Blue */
            --secondary-color: #FF7F50; /* Coral */
            --accent-color: #00A0A0; /* Teal for accents */
            --background-color: #F0F2F5; /* Light Grey */
            --card-background: #ffffff;
            --text-color: #333333;
            --light-text-color: #f8f9fa;
            --border-color: #d1d9e6;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --success-color: #28a745;
            --error-color: #dc3545;
            --border-radius-sm: 0.3rem;
            --border-radius-md: 0.6rem;
            --border-radius-lg: 0.9rem;
            --font-family-sans: 'Inter', sans-serif; /* Consider adding Google Font import for Inter */
        }
        /* Import Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: var(--font-family-sans); background-color: var(--background-color); color: var(--text-color); line-height: 1.7; display: flex; flex-direction: column; min-height: 100vh; font-weight: 400; }
        .container { width: 90%; max-width: 1200px; margin: 0 auto; padding: 0 15px; }

        .main-header { background-color: var(--card-background); padding: 1.2rem 0; box-shadow: 0 4px 12px var(--shadow-color); position: sticky; top: 0; z-index: 1000; }
        .main-header .container { display: flex; justify-content: space-between; align-items: center; }
        .logo { display: flex; align-items: center; text-decoration: none; color: var(--primary-color); }
        .logo-img { font-size: 2.2rem; margin-right: 0.85rem; color: var(--primary-color); transition: transform 0.3s ease; }
        .logo:hover .logo-img { transform: rotate(-5deg) scale(1.1); }
        .logo h1 { font-size: 2rem; font-weight: 700; }

        .tool-navigation { display: flex; align-items: center; gap: 1.2rem; }
        .nav-button { background-color: var(--primary-color); color: var(--light-text-color); padding: 0.7rem 1.4rem; border-radius: var(--border-radius-md); text-decoration: none; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; font-weight: 500; display: inline-flex; align-items: center; gap: 0.6rem; border: none; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .nav-button:hover { background-color: #005f80; transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .nav-button:disabled { background-color: #a0c7e4; cursor: not-allowed; transform: none; box-shadow: none; }
        .nav-button i { font-size: 1em; }
        .current-tool-name-header { font-size: 1.2rem; font-weight: 600; color: var(--text-color); }

        main { flex-grow: 1; padding: 2.5rem 0; }
        .page { display: none; animation: fadeInPage 0.6s ease-out; }
        .page.active { display: block; }
        @keyframes fadeInPage { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }

        .main-footer { background-color: #2c3e50; color: var(--light-text-color); text-align: center; padding: 2rem 0; margin-top: auto; }
        .main-footer p { margin: 0; font-size: 0.95rem; }
        .main-footer .fas.fa-heart { color: var(--secondary-color); }

        .text-center { text-align: center; }
        .mb-1 { margin-bottom: 0.5rem; } .mb-2 { margin-bottom: 1rem; } .mb-3 { margin-bottom: 1.5rem; }
        .mt-1 { margin-top: 0.5rem; } .mt-2 { margin-top: 1rem; } .mt-3 { margin-top: 1.5rem; }

        .btn { display: inline-block; padding: 0.85rem 1.8rem; border-radius: var(--border-radius-md); text-decoration: none; font-weight: 600; transition: all 0.3s ease; cursor: pointer; border: none; letter-spacing: 0.5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .btn i { margin-right: 8px; }
        .btn-primary { background-color: var(--primary-color); color: var(--light-text-color); }
        .btn-primary:hover { background-color: #005f80; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0, 123, 167, 0.3); }
        .btn-secondary { background-color: var(--secondary-color); color: var(--light-text-color); }
        .btn-secondary:hover { background-color: #e06938; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(255, 127, 80, 0.3); }
        .btn-danger { background-color: var(--error-color); color: var(--light-text-color); }
        .btn-danger:hover { background-color: #c82333; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(220, 53, 69, 0.3); }
        .btn-success { background-color: var(--success-color); color: var(--light-text-color); }
        .btn-success:hover { background-color: #218838; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(40, 167, 69, 0.3); }

        .dashboard-intro { text-align: center; margin-bottom: 3rem; padding: 2rem; background: linear-gradient(135deg, var(--primary-color), var(--accent-color)); color: var(--light-text-color); border-radius: var(--border-radius-lg); box-shadow: 0 8px 25px rgba(0, 123, 167, 0.2); }
        .dashboard-intro h2 { font-size: 2.8rem; margin-bottom: 0.75rem; font-weight: 700; }
        .dashboard-intro p { font-size: 1.2rem; max-width: 750px; margin: 0 auto; opacity: 0.9; }

        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 2rem; padding: 1rem 0; }
        .tool-card { background-color: var(--card-background); border-radius: var(--border-radius-lg); padding: 2rem 1.5rem; text-align: center; box-shadow: 0 6px 20px var(--shadow-color); transition: transform 0.35s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.35s cubic-bezier(0.25, 0.8, 0.25, 1); text-decoration: none; color: var(--text-color); display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 220px; cursor: pointer; opacity: 0; transform: translateY(25px); animation: fadeInUp 0.5s ease-out forwards; border: 1px solid transparent; }
        .tool-card:hover { transform: translateY(-10px) scale(1.04); box-shadow: 0 15px 35px rgba(0, 123, 167, 0.15); border-color: var(--primary-color); }
        .tool-card .tool-icon { font-size: 3.5rem; margin-bottom: 1.5rem; color: var(--primary-color); transition: transform 0.3s ease; }
        .tool-card:hover .tool-icon { transform: scale(1.15) rotate(8deg); color: var(--secondary-color); }
        .tool-card h3 { font-size: 1.35rem; margin-bottom: 0.6rem; font-weight: 600; }
        .tool-card p { font-size: 0.95rem; color: #555; line-height: 1.5; }
        @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }
        /* Staggered animation delays */
        .tool-card:nth-child(1) { animation-delay: 0.1s; } .tool-card:nth-child(2) { animation-delay: 0.18s; } .tool-card:nth-child(3) { animation-delay: 0.26s; } .tool-card:nth-child(4) { animation-delay: 0.34s; } .tool-card:nth-child(5) { animation-delay: 0.42s; } .tool-card:nth-child(6) { animation-delay: 0.5s; } .tool-card:nth-child(7) { animation-delay: 0.58s; } .tool-card:nth-child(8) { animation-delay: 0.66s; } .tool-card:nth-child(9) { animation-delay: 0.74s; } .tool-card:nth-child(10) { animation-delay: 0.82s; } .tool-card:nth-child(11) { animation-delay: 0.9s; } .tool-card:nth-child(12) { animation-delay: 0.98s; }


        .tool-container { background-color: var(--card-background); padding: 3rem; border-radius: var(--border-radius-lg); box-shadow: 0 10px 30px var(--shadow-color); max-width: 850px; margin: 1rem auto; }
        .tool-header { text-align: center; margin-bottom: 2.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 2rem; }
        .tool-header h2 { font-size: 2.4rem; color: var(--primary-color); font-weight: 700; }
        .tool-header .icon-header { margin-right: 0.75rem; }
        .tool-header p { font-size: 1.1rem; color: #555; margin-top: 0.75rem; }

        .upload-area { border: 3px dashed var(--border-color); border-radius: var(--border-radius-md); padding: 3.5rem 2.5rem; text-align: center; background-color: #fcfdff; transition: border-color 0.3s ease, background-color 0.3s ease, transform 0.2s ease; margin-bottom: 2.5rem; position: relative; }
        .upload-area.dragover { border-color: var(--secondary-color); background-color: #fff7f2; transform: scale(1.02); border-style: solid; }
        .upload-area .upload-icon { font-size: 3.5rem; color: var(--primary-color); margin-bottom: 1.2rem; display: block; transition: transform 0.3s ease; }
        .upload-area.dragover .upload-icon { transform: scale(1.1) rotate(-5deg); color: var(--secondary-color); }
        .upload-area p { margin-bottom: 1.5rem; font-size: 1.2rem; color: #666; }
        .upload-area .browse-files-btn { background-color: var(--secondary-color); color: var(--light-text-color); padding: 0.85rem 1.8rem; border-radius: var(--border-radius-md); cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; font-weight: 600; display: inline-block; }
        .upload-area .browse-files-btn:hover { background-color: #e06938; transform: translateY(-2px); }
        .hidden-file-input { display: none; }

        .file-list-container { margin-top: 2.5rem; }
        .file-list-header { font-size: 1.3rem; font-weight: 600; margin-bottom: 1.2rem; color: var(--primary-color); }
        .file-list { list-style: none; padding: 0; }
        .file-item { background-color: #f9fafb; border: 1px solid var(--border-color); padding: 1rem 1.5rem; border-radius: var(--border-radius-sm); margin-bottom: 0.85rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 3px 7px rgba(0,0,0,0.07); transition: background-color 0.2s ease, transform 0.2s ease; }
        .file-item:last-child { margin-bottom: 0; }
        .file-item.dragging { opacity: 0.6; background-color: #e6f0ff; transform: scale(1.03); border-style: dashed; border-color: var(--primary-color); }
        .file-item .file-name { font-size: 1rem; color: #333; flex-grow: 1; margin-right: 1.2rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500; }
        .file-item .file-actions button, .file-item .drag-handle { background: none; border: none; color: var(--primary-color); cursor: pointer; font-size: 1.2rem; margin-left: 0.6rem; padding: 0.35rem; transition: color 0.2s ease; }
        .file-item .drag-handle { cursor: grab; } .file-item .drag-handle:active { cursor: grabbing; }
        .file-item .file-actions button:hover { color: var(--secondary-color); }
        .file-item .file-actions .remove-btn { color: var(--error-color); }
        .file-item .file-actions .remove-btn:hover { color: #a71d2a; }

        .tool-options { margin-top: 2.5rem; padding-top: 2rem; border-top: 1px solid var(--border-color); }
        .tool-options h3 { font-size: 1.4rem; margin-bottom: 1.2rem; color: var(--primary-color); font-weight: 600; }
        .form-group { margin-bottom: 1.8rem; }
        .form-group label { display: block; margin-bottom: 0.6rem; font-weight: 500; color: #444; font-size: 0.95rem; }
        .form-group input[type="text"], .form-group input[type="number"], .form-group input[type="password"], .form-group input[type="color"], .form-group select, .form-group textarea { width: 100%; padding: 0.85rem 1rem; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); font-size: 1rem; transition: border-color 0.3s ease, box-shadow 0.3s ease; background-color: #fff; }
        .form-group input[type="text"]:focus, .form-group input[type="number"]:focus, .form-group input[type="password"]:focus, .form-group input[type="color"]:focus, .form-group select:focus, .form-group textarea:focus { border-color: var(--primary-color); box-shadow: 0 0 0 0.25rem rgba(0, 123, 167, 0.2); outline: none; }
        .form-group textarea { min-height: 120px; resize: vertical; }
        .form-group input[type="checkbox"] { margin-right: 0.5rem; transform: scale(1.1); }
        .checkbox-group div { margin-bottom: 0.5rem; }


        .action-buttons { margin-top: 3rem; text-align: center; display: flex; gap: 1.2rem; justify-content: center; }
        .processing-result-area { margin-top: 2rem; padding: 1.5rem; background-color: #e6f7ff; border: 1px solid var(--accent-color); border-radius: var(--border-radius-md); text-align: center; display: none; }
        .processing-result-area p { font-size: 1.1rem; color: var(--primary-color); margin-bottom: 1rem; }


        .organize-page-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 1.2rem; }
        .page-thumbnail { border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); padding: 0.6rem; text-align: center; position: relative; cursor: grab; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        /* ... other specific styles like .pdf-viewer-container, .page-thumbnail, etc., can be refined similarly ... */

        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255,255,255,0.85); backdrop-filter: blur(4px); z-index: 2000; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 1.6rem; color: var(--primary-color); display: none; }
        .loading-overlay .fas { margin-bottom: 1rem; font-size: 3rem; animation: spin 1s linear infinite; }
        .loading-overlay p { font-weight: 500; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        @media (max-width: 768px) { .logo h1 { font-size: 1.7rem; } .main-header .container { flex-direction: column; gap: 1.2rem; } .tool-navigation { width: 100%; justify-content: space-around; } .nav-button { padding: 0.6rem 1.1rem; } .tool-container { padding: 2rem 1.5rem; } .tool-header h2 { font-size: 2rem; } .upload-area { padding: 2.5rem 1.8rem; } }
        @media (max-width: 480px) { .logo-img { font-size: 1.9rem; margin-right: 0.6rem; } .logo h1 { font-size: 1.5rem; } .nav-button { font-size: 0.9rem; padding: 0.5rem 0.9rem; } .current-tool-name-header { font-size: 1rem; } .tool-grid { grid-template-columns: 1fr; } /* Single column for smallest screens */ .tool-card { min-height: 180px; } .tool-container { padding: 1.5rem 1rem; } .tool-header h2 { font-size: 1.7rem; } .upload-area { padding: 2rem 1rem; } .upload-area p { font-size: 1rem; } .upload-area .browse-files-btn { padding: 0.7rem 1.4rem; } .action-buttons { flex-direction: column; } .action-buttons .btn { width: 100%; margin-bottom: 0.5rem; } .organize-page-list { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); } }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay"><i class="fas fa-spinner"></i><p>Processing your request...</p></div>

    <header class="main-header">
        <div class="container">
            <a href="#" class="logo" id="homeLogoLink">
                <i class="fas fa-cogs logo-img"></i>
                <h1>PDF PowerSuite</h1>
            </a>
            <nav class="tool-navigation" id="headerToolNavigation" style="display: none;">
                <button id="backButton" class="nav-button"><i class="fas fa-chevron-left"></i> Back</button>
                <span class="current-tool-name-header" id="currentToolNameHeader">Tool Name</span>
                <button id="nextButton" class="nav-button">Next <i class="fas fa-chevron-right"></i></button>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            <div id="page-dashboard" class="page active">
                <section class="dashboard-intro">
                    <h2>Your Upgraded PDF Powerhouse</h2>
                    <p>Effortlessly convert, manage, edit, and secure your PDF files with our enhanced suite of powerful and intuitive tools. Select a tool below to begin!</p>
                </section>
                <section class="tool-grid">
                    <div class="tool-card" data-page="page-pdf-splitter"> <i class="fas fa-cut tool-icon"></i> <h3>PDF Splitter</h3> <p>Divide PDFs or extract pages.</p> </div>
                    <div class="tool-card" data-page="page-pdf-merger"> <i class="fas fa-link tool-icon"></i> <h3>PDF Merger</h3> <p>Combine multiple PDFs into one.</p> </div>
                    <div class="tool-card" data-page="page-image-to-pdf"> <i class="fas fa-file-image tool-icon"></i> <h3>Image to PDF</h3> <p>Convert JPG, PNG to PDF.</p> </div>
                    <div class="tool-card" data-page="page-text-to-pdf"> <i class="fas fa-file-alt tool-icon"></i> <h3>Text to PDF</h3> <p>Convert text or .txt to PDF.</p> </div>
                    <div class="tool-card" data-page="page-pdf-compressor"> <i class="fas fa-compress-arrows-alt tool-icon"></i> <h3>PDF Optimizer</h3> <p>Reduce PDF file size (basic).</p> </div>
                    <div class="tool-card" data-page="page-extract-text"> <i class="fas fa-quote-left tool-icon"></i> <h3>Extract Text</h3> <p>Pull text content from PDFs.</p> </div>
                    <div class="tool-card" data-page="page-combine-pdf-images"> <i class="fas fa-object-group tool-icon"></i> <h3>Combine PDFs & Images</h3> <p>Merge PDFs and images into one.</p> </div>
                    <div class="tool-card" data-page="page-organize-pdf"> <i class="fas fa-th-list tool-icon"></i> <h3>Organize PDF Pages</h3> <p>Rearrange or delete pages.</p> </div>
                    <div class="tool-card" data-page="page-lock-pdf"> <i class="fas fa-lock tool-icon"></i> <h3>Password Lock PDF</h3> <p>Secure PDFs with a password.</p> </div>
                    <div class="tool-card" data-page="page-unlock-pdf"> <i class="fas fa-unlock-alt tool-icon"></i> <h3>Remove PDF Password</h3> <p>Unlock protected PDFs.</p> </div>
                    <div class="tool-card" data-page="page-watermark-pdf"> <i class="fas fa-stamp tool-icon"></i> <h3>Add Watermark</h3> <p>Add watermarks to PDFs.</p> </div>
                </section>
            </div>

            <div id="page-pdf-splitter" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-cut icon-header"></i> PDF Splitter</h2> <p>Upload your PDF and choose how you want to split it.</p> </div>
                <div class="upload-area" id="splitterUploadArea"> <input type="file" class="hidden-file-input" id="splitterFileInput" accept=".pdf"> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF file here</strong> or</p> <label for="splitterFileInput" class="browse-files-btn">Browse File</label> </div>
                <div class="file-list-container" id="splitterFileListContainer" style="display: none;"> <h3 class="file-list-header">Uploaded File:</h3> <ul class="file-list" id="splitterFileList"></ul> </div>
                <div class="tool-options" id="splitterOptions" style="display: none;">
                    <h3>Split Options</h3>
                    <div class="form-group"> <label for="splitterSplitMode">Split Mode:</label> <select id="splitterSplitMode"> <option value="ranges">Extract specific page ranges</option> <option value="every_x_pages">Split every X pages</option> <option value="fixed_ranges">Split into fixed ranges of X pages</option> <option value="extract_all">Extract all pages into separate PDFs</option> </select> </div>
                    <div class="form-group splitter-conditional-option" data-mode="ranges"> <label for="splitterPageRanges">Page Ranges (e.g., 1-3, 5, 7-9):</label> <input type="text" id="splitterPageRanges" placeholder="e.g., 1-3, 5, 7-9"> </div>
                    <div class="form-group splitter-conditional-option" data-mode="every_x_pages" style="display:none;"> <label for="splitterEveryXPages">Split every X pages:</label> <input type="number" id="splitterEveryXPages" min="1" value="1"> </div>
                    <div class="form-group splitter-conditional-option" data-mode="fixed_ranges" style="display:none;"> <label for="splitterFixedRangeSize">Number of pages per split file:</label> <input type="number" id="splitterFixedRangeSize" min="1" value="1"> </div>
                </div>
                <div class="processing-result-area" id="splitterResultArea"> <p id="splitterResultMessage"></p> <button class="btn btn-success" id="splitterDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Processed PDF</button> </div>
                <div class="action-buttons" id="splitterActionButtons" style="display: none;"> <button class="btn btn-primary" id="splitterProcessButton"><i class="fas fa-cogs"></i> Split PDF</button> <button class="btn btn-danger" id="splitterResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-pdf-merger" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-link icon-header"></i> PDF Merger</h2> <p>Upload multiple PDF files to combine them. Drag and drop to reorder.</p> </div>
                <div class="upload-area" id="mergerUploadArea"> <input type="file" class="hidden-file-input" id="mergerFileInput" accept=".pdf" multiple> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF files here</strong> or</p> <label for="mergerFileInput" class="browse-files-btn">Browse Files</label> </div>
                <div class="file-list-container" id="mergerFileListContainer" style="display: none;"> <h3 class="file-list-header">Files to Merge (Drag to reorder):</h3> <ul class="file-list" id="mergerFileList"></ul> </div>
                <div class="tool-options" id="mergerOptions" style="display: none;"> <h3>Merge Options</h3> <div class="form-group"> <label for="mergerOutputFileName">Output File Name (optional):</label> <input type="text" id="mergerOutputFileName" placeholder="merged_document.pdf"> </div> </div>
                <div class="processing-result-area" id="mergerResultArea"> <p id="mergerResultMessage"></p> <button class="btn btn-success" id="mergerDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Merged PDF</button> </div>
                <div class="action-buttons" id="mergerActionButtons" style="display: none;"> <button class="btn btn-primary" id="mergerProcessButton"><i class="fas fa-cogs"></i> Merge PDFs</button> <button class="btn btn-danger" id="mergerResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-image-to-pdf" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-file-image icon-header"></i> Image to PDF Converter</h2> <p>Upload JPG or PNG images to convert them into a PDF document.</p> </div>
                <div class="upload-area" id="imageToPdfUploadArea"> <input type="file" class="hidden-file-input" id="imageToPdfFileInput" accept="image/jpeg,image/png" multiple> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your image files here</strong> or</p> <label for="imageToPdfFileInput" class="browse-files-btn">Browse Images</label> </div>
                <div class="file-list-container" id="imageToPdfFileListContainer" style="display: none;"> <h3 class="file-list-header">Images to Convert (Drag to reorder):</h3> <ul class="file-list" id="imageToPdfFileList"></ul> </div>
                <div class="tool-options" id="imageToPdfOptions" style="display: none;">
                    <h3>Conversion Options</h3>
                    <div class="form-group"> <label for="imageToPdfOutputFileName">Output PDF Name (optional):</label> <input type="text" id="imageToPdfOutputFileName" placeholder="converted_images.pdf"> </div>
                    <div class="form-group"> <label for="imageToPdfPageSize">Page Size:</label> <select id="imageToPdfPageSize"> <option value="A4">A4</option> <option value="Letter">Letter</option> <option value="image_size">Fit to Image (first image dimensions)</option></select></div>
                    <div class="form-group"> <label for="imageToPdfMargin">Page Margin (pixels):</label> <input type="number" id="imageToPdfMargin" value="50" min="0" step="5"></div>
                     <div class="form-group"> <label for="imageToPdfOutputMode">Output Mode:</label> <select id="imageToPdfOutputMode"> <option value="merge">Merge all images into one PDF</option> </select> <small>Individual PDFs (zipped) coming soon!</small></div>
                </div>
                <div class="processing-result-area" id="imageToPdfResultArea"> <p id="imageToPdfResultMessage"></p> <button class="btn btn-success" id="imageToPdfDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download PDF</button> </div>
                <div class="action-buttons" id="imageToPdfActionButtons" style="display: none;"> <button class="btn btn-primary" id="imageToPdfProcessButton"><i class="fas fa-cogs"></i> Convert to PDF</button> <button class="btn btn-danger" id="imageToPdfResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-text-to-pdf" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-file-alt icon-header"></i> Text to PDF Converter</h2> <p>Type text, paste, or upload a .txt file to convert to PDF.</p> </div>
                <div class="upload-area" id="textToPdfUploadArea"> <input type="file" class="hidden-file-input" id="textToPdfFileInput" accept=".txt"> <i class="fas fa-file-upload upload-icon"></i> <p><strong>Drag & drop your .txt file here</strong> or <label for="textToPdfFileInput" class="browse-files-btn">Browse .txt File</label></p>
                <p class="mt-2 mb-2">OR Enter/Paste Text Below:</p>
                <textarea id="textToPdfTextArea" rows="10" placeholder="Enter your text here..."></textarea>
                </div>
                <div class="file-list-container" id="textToPdfFileListContainer" style="display: none;"> <h3 class="file-list-header">Uploaded .txt File:</h3> <ul class="file-list" id="textToPdfFileList"></ul> </div>

                <div class="tool-options" id="textToPdfOptions" style="display: none;"> <h3>PDF Options</h3>
                    <div class="form-group"> <label for="textToPdfOutputFileName">Output PDF Name (optional):</label> <input type="text" id="textToPdfOutputFileName" placeholder="text_document.pdf"> </div>
                    <div class="form-group"> <label for="textToPdfPageSize">Page Size:</label> <select id="textToPdfPageSizeCmb"> <option value="A4">A4</option> <option value="Letter">Letter</option></select></div>
                    <div class="form-group"> <label for="textToPdfFont">Font:</label> <select id="textToPdfFont"> <option value="Helvetica">Helvetica</option> <option value="TimesRoman">Times Roman</option> <option value="Courier">Courier</option> </select></div>
                    <div class="form-group"> <label for="textToPdfFontSize">Font Size:</label> <input type="number" id="textToPdfFontSize" value="12" min="6" max="72"></div>
                    <div class="form-group"> <label for="textToPdfMargin">Page Margin (points):</label> <input type="number" id="textToPdfMarginInput" value="50" min="10" step="5"></div>
                </div>
                <div class="processing-result-area" id="textToPdfResultArea"> <p id="textToPdfResultMessage"></p> <button class="btn btn-success" id="textToPdfDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download PDF</button> </div>
                <div class="action-buttons" id="textToPdfActionButtons" style="display: block;"> <button class="btn btn-primary" id="textToPdfProcessButton"><i class="fas fa-cogs"></i> Convert to PDF</button> <button class="btn btn-danger" id="textToPdfResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>


            <div id="page-pdf-compressor" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-compress-arrows-alt icon-header"></i> PDF Optimizer</h2> <p>Reduce the file size of your PDF using basic optimizations.</p> </div>
                <div class="upload-area" id="compressorUploadArea"> <input type="file" class="hidden-file-input" id="compressorFileInput" accept=".pdf"> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF file here</strong> or</p> <label for="compressorFileInput" class="browse-files-btn">Browse File</label> </div>
                <div class="file-list-container" id="compressorFileListContainer" style="display: none;"> <h3 class="file-list-header">File to Optimize:</h3> <ul class="file-list" id="compressorFileList"></ul> </div>
                <div class="tool-options" id="compressorOptions" style="display:none;"> <h3>Optimization Level</h3> <div class="form-group"> <label for="compressorLevel">Select optimization level:</label> <select id="compressorLevel"> <option value="basic" selected>Basic Optimization (subset fonts, remove unused, object streams)</option> </select> <p class="mt-1"><small>Advanced compression is complex client-side. This tool performs common PDF library optimizations.</small></p></div> </div>
                <div class="processing-result-area" id="compressorResultArea"> <p id="compressorResultMessage"></p> <button class="btn btn-success" id="compressorDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Optimized PDF</button> </div>
                <div class="action-buttons" id="compressorActionButtons" style="display: none;"> <button class="btn btn-primary" id="compressorProcessButton"><i class="fas fa-cogs"></i> Optimize PDF</button> <button class="btn btn-danger" id="compressorResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-extract-text" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-quote-left icon-header"></i> Extract Text from PDF</h2> <p>Upload a PDF to extract its text content. Uses PDF.js library.</p> </div>
                <div class="upload-area" id="extractUploadArea"> <input type="file" class="hidden-file-input" id="extractFileInput" accept=".pdf"> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF file here</strong> or</p> <label for="extractFileInput" class="browse-files-btn">Browse File</label> </div>
                <div class="file-list-container" id="extractFileListContainer" style="display: none;"> <h3 class="file-list-header">File for Text Extraction:</h3> <ul class="file-list" id="extractFileList"></ul> </div>
                 <div id="extractResultContainer" style="display:none; margin-top: 2rem;"> <h3>Extracted Text:</h3> <textarea id="extractedTextOutput" rows="12" readonly style="width: 100%; font-family: monospace; padding: 0.75rem; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); background-color: #f8f9fa;"></textarea> <button class="btn btn-secondary mt-2" id="copyExtractedTextButton"><i class="fas fa-copy"></i> Copy Text</button> </div>
                <div class="processing-result-area" id="extractResultArea" style="padding:0.5rem;"> <p id="extractResultMessage" style="margin-bottom:0;"></p> </div> <div class="action-buttons" id="extractActionButtons" style="display: none;"> <button class="btn btn-primary" id="extractProcessButton"><i class="fas fa-cogs"></i> Extract Text</button> <button class="btn btn-danger" id="extractResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-combine-pdf-images" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-object-group icon-header"></i> Combine PDFs & Images</h2> <p>Merge PDF documents and image files (JPG, PNG) into a single PDF.</p> </div>
                <div class="upload-area" id="combineUploadArea"> <input type="file" class="hidden-file-input" id="combineFileInput" accept=".pdf,.jpg,.jpeg,.png" multiple> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF/Image files here</strong> or</p> <label for="combineFileInput" class="browse-files-btn">Browse Files</label> </div>
                <div class="file-list-container" id="combineFileListContainer" style="display: none;"> <h3 class="file-list-header">Files to Combine (Drag to reorder):</h3> <ul class="file-list" id="combineFileList"></ul> </div>
                <div class="tool-options" id="combineOptions" style="display: none;"> <h3>Output Options</h3> <div class="form-group"> <label for="combineOutputFileName">Output File Name (optional):</label> <input type="text" id="combineOutputFileName" placeholder="combined_document.pdf"> </div> </div>
                <div class="processing-result-area" id="combineResultArea"> <p id="combineResultMessage"></p> <button class="btn btn-success" id="combineDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Combined PDF</button> </div>
                <div class="action-buttons" id="combineActionButtons" style="display: none;"> <button class="btn btn-primary" id="combineProcessButton"><i class="fas fa-cogs"></i> Combine Files</button> <button class="btn btn-danger" id="combineResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-organize-pdf" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-th-list icon-header"></i> Organize PDF Pages</h2> <p>Upload a PDF to rearrange or delete its pages. Drag to reorder.</p> </div>
                <div class="upload-area" id="organizeUploadArea"> <input type="file" class="hidden-file-input" id="organizeFileInput" accept=".pdf"> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF file here</strong> or</p> <label for="organizeFileInput" class="browse-files-btn">Browse File</label> </div>
                <div id="organizePagePreviewArea" style="display:none;"> <h3 class="file-list-header">Organize Pages (Drag to reorder, click trash to delete):</h3> <ul class="file-list organize-page-list" id="organizePageList"> </ul> <p><small>Note: Thumbnails are representative page items, not full previews.</small></p></div>
                <div class="processing-result-area" id="organizeResultArea"> <p id="organizeResultMessage"></p> <button class="btn btn-success" id="organizeDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Organized PDF</button> </div>
                <div class="action-buttons" id="organizeActionButtons" style="display: none;"> <button class="btn btn-primary" id="organizeProcessButton"><i class="fas fa-save"></i> Save Changes</button> <button class="btn btn-danger" id="organizeResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-lock-pdf" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-lock icon-header"></i> Password Lock PDF</h2> <p>Secure your PDF file with a user and/or owner password.</p> </div>
                <div class="upload-area" id="lockUploadArea"> <input type="file" class="hidden-file-input" id="lockFileInput" accept=".pdf"> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF file here</strong> or</p> <label for="lockFileInput" class="browse-files-btn">Browse File</label> </div>
                <div class="file-list-container" id="lockFileListContainer" style="display: none;"> <h3 class="file-list-header">File to Lock:</h3> <ul class="file-list" id="lockFileList"></ul> </div>
                <div class="tool-options" id="lockOptions" style="display:none;">
                    <h3>Set Passwords & Permissions</h3>
                    <div class="form-group"> <label for="lockUserPassword">User Password (to open the PDF):</label> <input type="password" id="lockUserPassword" placeholder="Enter user password"> </div>
                    <div class="form-group"> <label for="lockOwnerPassword">Owner Password (restricts editing, printing etc. - Optional):</label> <input type="password" id="lockOwnerPassword" placeholder="Enter owner password"> <small>If only Owner Password is set, PDF opens without password but permissions apply.</small></div>
                    <div class="form-group checkbox-group">
                        <label>Permissions (apply if Owner Password is set):</label>
                        <div><input type="checkbox" id="permPrinting" checked> Allow Printing</div>
                        <div><input type="checkbox" id="permModifying" checked> Allow Modifying</div>
                        <div><input type="checkbox" id="permCopying" checked> Allow Copying Content</div>
                        <div><input type="checkbox" id="permAnnotations" checked> Allow Annotating & Form Filling</div>
                    </div>
                </div>
                <div class="processing-result-area" id="lockResultArea"> <p id="lockResultMessage"></p> <button class="btn btn-success" id="lockDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Locked PDF</button> </div>
                <div class="action-buttons" id="lockActionButtons" style="display: none;"> <button class="btn btn-primary" id="lockProcessButton"><i class="fas fa-key"></i> Lock PDF</button> <button class="btn btn-danger" id="lockResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-unlock-pdf" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-unlock-alt icon-header"></i> Remove PDF Password</h2> <p>Upload a password-protected PDF to remove its password (if you know it).</p> </div>
                <div class="upload-area" id="unlockUploadArea"> <input type="file" class="hidden-file-input" id="unlockFileInput" accept=".pdf"> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF file here</strong> or</p> <label for="unlockFileInput" class="browse-files-btn">Browse File</label> </div>
                <div class="file-list-container" id="unlockFileListContainer" style="display: none;"> <h3 class="file-list-header">File to Unlock:</h3> <ul class="file-list" id="unlockFileList"></ul> </div>
                <div class="tool-options" id="unlockOptions" style="display:none;"> <h3>Enter Current Password(s)</h3> <div class="form-group"> <label for="unlockUserPassword">User Password (if set for opening):</label> <input type="password" id="unlockUserPassword" placeholder="Enter user password"> </div> <div class="form-group"> <label for="unlockOwnerPassword">Owner Password (if only permissions are locked):</label> <input type="password" id="unlockOwnerPassword" placeholder="Enter owner password"> </div> <small>Provide the password that protects the document. If both are set, user password usually takes precedence for opening. If file is not encrypted, it will be saved as unprotected.</small></div>
                <div class="processing-result-area" id="unlockResultArea"> <p id="unlockResultMessage"></p> <button class="btn btn-success" id="unlockDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Unlocked PDF</button> </div>
                <div class="action-buttons" id="unlockActionButtons" style="display: none;"> <button class="btn btn-primary" id="unlockProcessButton"><i class="fas fa-key"></i> Unlock PDF</button> <button class="btn btn-danger" id="unlockResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

            <div id="page-watermark-pdf" class="page"> <div class="tool-container">
                <div class="tool-header"> <h2><i class="fas fa-stamp icon-header"></i> Add Watermark to PDF</h2> <p>Add a text or image watermark to your PDF document.</p> </div>
                <div class="upload-area" id="watermarkUploadArea"> <input type="file" class="hidden-file-input" id="watermarkFileInput" accept=".pdf"> <i class="fas fa-cloud-upload-alt upload-icon"></i> <p><strong>Drag & drop your PDF file here</strong> or</p> <label for="watermarkFileInput" class="browse-files-btn">Browse File</label> </div>
                <div class="file-list-container" id="watermarkFileListContainer" style="display: none;"> <h3 class="file-list-header">File to Watermark:</h3> <ul class="file-list" id="watermarkFileList"></ul> </div>
                <div class="tool-options" id="watermarkOptions" style="display:none;">
                    <h3>Watermark Settings</h3>
                    <div class="form-group"> <label for="watermarkType">Watermark Type:</label> <select id="watermarkType"> <option value="text" selected>Text Watermark</option> <option value="image">Image Watermark</option> </select> </div>
                    <div class="form-group" id="watermarkTextGroup"> <label for="watermarkText">Watermark Text:</label> <input type="text" id="watermarkText" placeholder="e.g., CONFIDENTIAL"> </div>
                    <div class="form-group" id="watermarkImageGroup" style="display:none;"> <label for="watermarkImageFile">Upload Watermark Image (PNG/JPG):</label> <input type="file" id="watermarkImageFile" accept="image/png, image/jpeg"> </div>
                    <div class="form-group"> <label for="watermarkOpacity">Opacity (0.1 to 1.0):</label> <input type="number" id="watermarkOpacity" min="0.1" max="1.0" step="0.05" value="0.3"> </div>
                    <div class="form-group"> <label for="watermarkRotation">Rotation (degrees):</label> <input type="number" id="watermarkRotation" min="-360" max="360" step="1" value="-45"> </div>
                    <div class="form-group"> <label for="watermarkFontSize">Font Size (for text):</label> <input type="number" id="watermarkFontSize" min="8" value="72"> </div>
                    <div class="form-group"> <label for="watermarkColor">Font Color (for text):</label> <input type="color" id="watermarkColor" value="#C0C0C0"> </div>
                     <div class="form-group"> <label for="watermarkScale">Image Scale (for image, e.g., 0.5 for 50%):</label> <input type="number" id="watermarkScale" min="0.1" max="2.0" step="0.1" value="0.5"> </div>
                    <div class="form-group">
                        <label for="watermarkPosition">Position:</label>
                        <select id="watermarkPosition">
                            <option value="center">Center</option>
                            <option value="top_left">Top Left</option>
                            <option value="top_right">Top Right</option>
                            <option value="bottom_left">Bottom Left</option>
                            <option value="bottom_right">Bottom Right</option>
                            <option value="tile">Tile (Repeat)</option>
                        </select>
                    </div>
                </div>
                <div class="processing-result-area" id="watermarkResultArea"> <p id="watermarkResultMessage"></p> <button class="btn btn-success" id="watermarkDownloadButton" style="display:none;"><i class="fas fa-download"></i> Download Watermarked PDF</button> </div>
                <div class="action-buttons" id="watermarkActionButtons" style="display: none;"> <button class="btn btn-primary" id="watermarkProcessButton"><i class="fas fa-stamp"></i> Add Watermark</button> <button class="btn btn-danger" id="watermarkResetButton"><i class="fas fa-trash-alt"></i> Reset</button> </div>
            </div> </div>

        </div> </main>

    <footer class="main-footer">
        <div class="container">
            <p>&copy; 2025 PDF PowerSuite (Enhanced). All rights reserved. Made with <i class="fas fa-heart"></i>.</p>
        </div>
    </footer>

    <script>
        const { PDFDocument, rgb, StandardFonts, degrees, PageSizes, grayscale } = PDFLib;

        document.addEventListener('DOMContentLoaded', () => {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const pages = document.querySelectorAll('.page');
            const toolCards = document.querySelectorAll('.tool-card');
            const homeLogoLink = document.getElementById('homeLogoLink');
            const headerToolNavigation = document.getElementById('headerToolNavigation');
            const currentToolNameHeader = document.getElementById('currentToolNameHeader');
            const backButton = document.getElementById('backButton');
            const nextButton = document.getElementById('nextButton');

            // Updated tool order to include new tools
            const toolOrder = [
                { id: 'page-dashboard', name: 'Dashboard' },
                { id: 'page-pdf-splitter', name: 'PDF Splitter' },
                { id: 'page-pdf-merger', name: 'PDF Merger' },
                { id: 'page-image-to-pdf', name: 'Image to PDF' },
                { id: 'page-text-to-pdf', name: 'Text to PDF' },
                { id: 'page-pdf-compressor', name: 'PDF Optimizer' },
                { id: 'page-extract-text', name: 'Extract Text' },
                { id: 'page-combine-pdf-images', name: 'Combine PDFs & Images' },
                { id: 'page-organize-pdf', name: 'Organize PDF' },
                { id: 'page-lock-pdf', name: 'Lock PDF' },
                { id: 'page-unlock-pdf', name: 'Unlock PDF' },
                { id: 'page-watermark-pdf', name: 'Add Watermark' }
            ];
            let currentPageIndex = 0;
            let processedPdfBytesStore = {}; // To store bytes for download button { toolPrefix: bytes }

            function showLoading(show) {
                loadingOverlay.style.display = show ? 'flex' : 'none';
            }

            function showPage(pageId) {
                pages.forEach(page => {
                    page.classList.remove('active');
                    if (page.id === pageId) page.classList.add('active');
                });
                currentPageIndex = toolOrder.findIndex(tool => tool.id === pageId);
                if (pageId === 'page-dashboard') {
                    headerToolNavigation.style.display = 'none';
                } else {
                    headerToolNavigation.style.display = 'flex';
                    currentToolNameHeader.textContent = toolOrder[currentPageIndex]?.name || 'Tool';
                    backButton.disabled = currentPageIndex <= 1; // Disable back if first tool or dashboard
                    nextButton.disabled = currentPageIndex >= toolOrder.length - 1;
                }
                window.scrollTo(0,0);
            }
            toolCards.forEach(card => card.addEventListener('click', () => showPage(card.dataset.page)));
            homeLogoLink.addEventListener('click', (e) => { e.preventDefault(); showPage('page-dashboard'); });
            backButton.addEventListener('click', () => {
                if (currentPageIndex > 0) showPage(toolOrder[currentPageIndex - 1].id); // Go to previous, or dashboard if at first tool
            });
            nextButton.addEventListener('click', () => {
                if (currentPageIndex < toolOrder.length - 1) showPage(toolOrder[currentPageIndex + 1].id);
            });

            function readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
            
            function readFileAsDataURL(file) {
                 return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            function triggerDownload(bytes, filename) {
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }

            // Modified Download/Result Handling
            function showProcessingResult(toolPrefix, message, success = true, filename = null, bytes = null) {
                const resultArea = document.getElementById(`${toolPrefix}ResultArea`);
                const resultMessageEl = document.getElementById(`${toolPrefix}ResultMessage`);
                const downloadButton = document.getElementById(`${toolPrefix}DownloadButton`);

                if (resultArea && resultMessageEl) {
                    resultMessageEl.textContent = message;
                    resultArea.style.display = 'block';
                    resultArea.style.backgroundColor = success ? '#e6fff2' : '#ffe6e6'; // Green for success, Red for error
                    resultMessageEl.style.color = success ? 'var(--success-color)' : 'var(--error-color)';
                }

                if (downloadButton) {
                    if (success && bytes && filename) {
                        processedPdfBytesStore[toolPrefix] = { bytes, filename };
                        downloadButton.style.display = 'inline-block';
                        downloadButton.onclick = () => {
                            triggerDownload(processedPdfBytesStore[toolPrefix].bytes, processedPdfBytesStore[toolPrefix].filename);
                        };
                    } else {
                        downloadButton.style.display = 'none';
                    }
                }
                showLoading(false);
            }


            function setupFileUpload(toolPrefix, isMultiple = false, acceptedTypes = ".pdf") {
                const uploadArea = document.getElementById(`${toolPrefix}UploadArea`);
                const fileInput = document.getElementById(`${toolPrefix}FileInput`);
                const fileListContainer = document.getElementById(`${toolPrefix}FileListContainer`);
                const fileListUl = document.getElementById(`${toolPrefix}FileList`);
                const optionsDiv = document.getElementById(`${toolPrefix}Options`);
                const actionsDiv = document.getElementById(`${toolPrefix}ActionButtons`);
                const resetButton = document.getElementById(`${toolPrefix}ResetButton`);
                const resultArea = document.getElementById(`${toolPrefix}ResultArea`);
                let currentFiles = [];

                function displayFiles() {
                    if (!fileListUl) return; // For tools like textToPdf that might not always show a list
                    fileListUl.innerHTML = '';
                    currentFiles.forEach((file, index) => {
                        const listItem = document.createElement('li');
                        listItem.classList.add('file-item');
                        if (isMultiple && toolPrefix !== 'organize' && toolPrefix !== 'imageToPdf') { // imageToPdf specific reorder
                            listItem.setAttribute('draggable', 'true');
                            listItem.dataset.id = index; // original index in currentFiles
                            listItem.innerHTML = `<i class="fas fa-grip-vertical drag-handle" title="Drag to reorder"></i>`;
                        } else if (isMultiple && toolPrefix === 'imageToPdf') {
                             listItem.setAttribute('draggable', 'true');
                             listItem.dataset.id = index;
                             listItem.innerHTML = `<i class="fas fa-grip-vertical drag-handle" title="Drag to reorder"></i>`;
                        } else { listItem.innerHTML = ''; }

                        listItem.innerHTML += `<span class="file-name" title="${file.name}">${file.name} (${(file.size / 1024).toFixed(1)} KB)</span>
                                               <span class="file-actions"><button class="remove-btn" title="Remove file" data-index="${index}"><i class="fas fa-times-circle"></i></button></span>`;
                        fileListUl.appendChild(listItem);
                    });

                    const hasFiles = currentFiles.length > 0;
                    if (fileListContainer) fileListContainer.style.display = hasFiles ? 'block' : 'none';
                    if (optionsDiv) optionsDiv.style.display = hasFiles ? 'block' : 'none';
                    if (actionsDiv) actionsDiv.style.display = hasFiles ? 'flex' : 'none';
                    
                    if (uploadArea) {
                        if (!isMultiple && hasFiles) {
                            uploadArea.style.display = 'none';
                        } else if (isMultiple) { // For multiple, always allow adding more, so don't hide upload area completely
                           // uploadArea.style.display = 'block'; // Or style it differently
                        } else {
                            uploadArea.style.display = 'block';
                        }
                    }
                     // Special handling for textToPdf tool
                    if (toolPrefix === 'textToPdf') {
                        const textArea = document.getElementById('textToPdfTextArea');
                        const hasText = textArea && textArea.value.trim().length > 0;
                        if (optionsDiv) optionsDiv.style.display = (hasFiles || hasText) ? 'block' : 'none';
                        if (actionsDiv) actionsDiv.style.display = (hasFiles || hasText) ? 'flex' : 'none';
                        if (uploadArea && hasFiles && !isMultiple) uploadArea.style.display = 'none'; // Hide if a .txt is uploaded
                    }


                    fileListUl.querySelectorAll('.remove-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const indexToRemove = parseInt(this.dataset.index);
                            currentFiles.splice(indexToRemove, 1);
                            displayFiles(); // Re-render
                            if (currentFiles.length === 0 && uploadArea && !isMultiple) {
                                uploadArea.style.display = 'block';
                            }
                             // Special handling for textToPdf tool on remove
                            if (toolPrefix === 'textToPdf') {
                                const textArea = document.getElementById('textToPdfTextArea');
                                const hasText = textArea && textArea.value.trim().length > 0;
                                if (optionsDiv) optionsDiv.style.display = (currentFiles.length > 0 || hasText) ? 'block' : 'none';
                                if (actionsDiv) actionsDiv.style.display = (currentFiles.length > 0 || hasText) ? 'flex' : 'none';
                                if(currentFiles.length === 0) uploadArea.style.display = 'block';
                            }
                        });
                    });
                    if (isMultiple && (toolPrefix === 'merger' || toolPrefix === 'combine' || toolPrefix === 'imageToPdf')) {
                         addDragReorderListeners(fileListUl, currentFiles, displayFiles);
                    }
                }

                function handleFileSelect(files) {
                    const newFilesArray = Array.from(files).filter(f => {
                        const typeParts = f.type.split('/');
                        const mainType = typeParts[0];
                        const subType = typeParts[1];
                        return acceptedTypes.includes(`.${subType}`) || acceptedTypes.includes(`${mainType}/*`) || acceptedTypes.includes(f.type) || acceptedTypes === '*/*';
                    });

                    if (newFilesArray.length === 0 && files.length > 0) {
                        alert(`Invalid file type. Please upload files of type: ${acceptedTypes}`);
                        fileInput.value = '';
                        return;
                    }

                    if (!isMultiple) {
                        currentFiles = newFilesArray.length > 0 ? [newFilesArray[0]] : [];
                    } else {
                        newFilesArray.forEach(nf => {
                            if (!currentFiles.some(cf => cf.name === nf.name && cf.lastModified === nf.lastModified && cf.size === nf.size)) {
                                currentFiles.push(nf);
                            }
                        });
                    }
                    displayFiles();
                    fileInput.value = ''; // Clear input to allow re-uploading same file
                }

                if(uploadArea && fileInput) {
                    uploadArea.addEventListener('click', (e) => { if (e.target !== fileInput && e.target.tagName !== 'LABEL' && !e.target.classList.contains('browse-files-btn')) fileInput.click(); });
                    uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
                    uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
                    uploadArea.addEventListener('drop', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); handleFileSelect(e.dataTransfer.files); });
                    fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files));
                }
                
                // For TextToPdf, also trigger display update on textarea input
                if (toolPrefix === 'textToPdf') {
                    const textArea = document.getElementById('textToPdfTextArea');
                    if (textArea) {
                        textArea.addEventListener('input', () => {
                             const hasText = textArea.value.trim().length > 0;
                             const hasFiles = currentFiles.length > 0;
                             if (optionsDiv) optionsDiv.style.display = (hasFiles || hasText) ? 'block' : 'none';
                             if (actionsDiv) actionsDiv.style.display = (hasFiles || hasText) ? 'flex' : 'none';
                        });
                    }
                     // Initial check for text area content
                    if (optionsDiv) optionsDiv.style.display = 'none'; // Hide options initially
                    if (actionsDiv) actionsDiv.style.display = 'flex'; // Keep actions always visible, but process button might be disabled later
                }


                function resetToolSpecific(){
                    if (toolPrefix === 'extract') {
                         document.getElementById('extractedTextOutput').value = '';
                         document.getElementById('extractResultContainer').style.display = 'none';
                    }
                    if (toolPrefix === 'organize') {
                        organizePdfDoc = null;
                        organizePageObjects.length = 0;
                        if(document.getElementById('organizePagePreviewArea')) document.getElementById('organizePagePreviewArea').style.display = 'none';
                        if(document.getElementById('organizePageList')) document.getElementById('organizePageList').innerHTML = '';
                    }
                    if (toolPrefix === 'textToPdf') {
                        const textArea = document.getElementById('textToPdfTextArea');
                        if(textArea) textArea.value = '';
                        // Options and actions visibility will be handled by displayFiles or initial setup
                    }
                    if (resultArea) resultArea.style.display = 'none';
                    const downloadButton = document.getElementById(`${toolPrefix}DownloadButton`);
                    if(downloadButton) downloadButton.style.display = 'none';
                    delete processedPdfBytesStore[toolPrefix];
                }

                function resetTool() {
                    currentFiles = [];
                    displayFiles(); // This will hide options/actions if no files
                    resetToolSpecific();
                    if (uploadArea && (isMultiple || currentFiles.length === 0)) { // Show upload area if multiple allowed or if single and no files
                         uploadArea.style.display = 'block';
                    }
                     // Special handling for textToPdf to ensure options/actions are hidden if no text and no file
                    if (toolPrefix === 'textToPdf') {
                        const textArea = document.getElementById('textToPdfTextArea');
                        const hasText = textArea && textArea.value.trim().length > 0;
                        if (optionsDiv) optionsDiv.style.display = hasText ? 'block' : 'none';
                        if (actionsDiv) actionsDiv.style.display = hasText ? 'flex' : 'block'; // Or 'flex' if you prefer
                        if (uploadArea) uploadArea.style.display = 'block'; // Always show upload for .txt for textToPdf on reset
                    }
                }
                if(resetButton) resetButton.addEventListener('click', resetTool);
                
                // Initial state for options and actions
                if (optionsDiv && toolPrefix !== 'textToPdf') optionsDiv.style.display = 'none';
                if (actionsDiv && toolPrefix !== 'textToPdf') actionsDiv.style.display = 'none';


                return { getFiles: () => currentFiles, displayFiles, resetTool, handleFileSelect };
            }

            function addDragReorderListeners(listElement, filesArrayRef, renderCallback) {
                let draggedItem = null;
                let placeholder = null;

                function createPlaceholder() {
                    const ph = document.createElement('li');
                    ph.classList.add('file-item-placeholder'); // Add specific styling for placeholder
                    ph.style.height = draggedItem ? `${draggedItem.offsetHeight}px` : '50px';
                    ph.style.backgroundColor = 'rgba(0,0,0,0.05)';
                    ph.style.border = '2px dashed var(--border-color)';
                    ph.style.marginBottom = '0.85rem';
                    ph.style.borderRadius = 'var(--border-radius-sm)';
                    return ph;
                }

                listElement.querySelectorAll('.file-item[draggable="true"]').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        draggedItem = item;
                        setTimeout(() => item.classList.add('dragging'), 0);
                        e.dataTransfer.effectAllowed = 'move';
                        // Optional: Set drag image if needed
                        // e.dataTransfer.setData('text/plain', item.dataset.id);

                        placeholder = createPlaceholder();
                    });

                    item.addEventListener('dragend', () => {
                        if (!draggedItem) return;
                        draggedItem.classList.remove('dragging');
                        draggedItem = null;
                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.removeChild(placeholder);
                        }
                        placeholder = null;

                        // Update the actual filesArrayRef based on DOM order
                        const newOrderedFiles = [];
                        Array.from(listElement.children).forEach(childItem => {
                            if (childItem.classList.contains('file-item') && childItem.dataset.id) {
                                // Find the original file object using its initial dataset.id stored at dragstart if needed
                                // For this setup, currentFiles is directly manipulated by splicing and pushing.
                                // The important part is that filesArrayRef itself needs to be mutated
                                // The current filesArrayRef is passed by reference and elements are moved.
                            }
                        });
                        // The actual reordering of filesArrayRef needs to happen based on final DOM
                        const tempReordered = [];
                        const currentItemsInDom = Array.from(listElement.querySelectorAll('.file-item[draggable="true"]'));
                        
                        const currentFiles = filesArrayRef; // get the actual array
                        const newFilesOrder = [];
                        currentItemsInDom.forEach(domItem => {
                            const originalIndex = parseInt(domItem.dataset.originalOrderIndex || domItem.dataset.id); // Use a persistent original index
                            newFilesOrder.push(currentFiles.find(f => f.originalOrderIndex === originalIndex || f.name === domItem.querySelector('.file-name').textContent.split(' (')[0] )); // A bit hacky, better to tag files with unique ID
                        });

                        // A simpler approach if renderCallback re-reads from DOM to update array:
                        // After drag end, get all .file-item elements in their new order
                        const domOrder = Array.from(listElement.children)
                                           .filter(child => child.classList.contains('file-item') && child.dataset.id !== undefined)
                                           .map(child => parseInt(child.dataset.id)); // These are original indices

                        const reorderedActualFiles = domOrder.map(originalIndex =>
                            filesArrayRef.find((file, idx) => (file.originalIndexForReorder === undefined ? idx : file.originalIndexForReorder) === originalIndex)
                        );

                        // Clear and repopulate the filesArrayRef with the new order
                        // This requires that file objects in filesArrayRef have an 'originalIndexForReorder' property set when first added.
                        // Let's refine this. `filesArrayRef` is an array of File objects.
                        // We need to map the new DOM order of list items back to the order of these File objects.

                        let originalIndices = filesArrayRef.map((_,i) => i); // Assume filesArrayRef holds original File objects in some order
                                                                              // and item.dataset.id refers to the index in *that current* filesArrayRef before this drag.

                        const finalFileOrder = [];
                        Array.from(listElement.children).forEach(childNode => {
                            if (childNode.classList.contains('file-item') && childNode.dataset.id !== undefined) {
                                // childNode.dataset.id was the index in the filesArrayRef *before* this specific drag started for that item
                                // This is tricky because filesArrayRef itself might be reordered by multiple drags.
                                // Best is to attach a non-changing unique ID to each file object and its list item.
                                // For now, let's assume dataset.id is enough if renderCallback is smart.

                                // The provided `addDragReorderListeners` in the problem description used `parseInt(child.dataset.id)`
                                // and then `newOrderIndices.map(originalIndex => filesArray[originalIndex])`.
                                // This implies `filesArray` (our `filesArrayRef`) is not mutated until the end, and `dataset.id` refers to original indices in *that specific invocation*.
                                // This is simpler to manage if `filesArrayRef` is treated as immutable during this specific reorder, and a new array is formed.
                            }
                        });
                        // The original code snippet had issues with reordering the actual array.
                        // A robust way: give each file a unique ID when added.
                        // Store this ID in item.dataset.fileId.
                        // On dragend, iterate listElement.children, get fileIds, then reorder filesArrayRef.
                        renderCallback(); // This function should re-render the list based on the updated filesArrayRef order.

                    });

                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (!draggedItem || draggedItem === item || !placeholder) return;
                        e.dataTransfer.dropEffect = 'move';

                        const rect = item.getBoundingClientRect();
                        const offsetY = e.clientY - rect.top;
                        const isAfter = offsetY > rect.height / 2;

                        if (isAfter) {
                            listElement.insertBefore(placeholder, item.nextSibling);
                            listElement.insertBefore(draggedItem, item.nextSibling);
                        } else {
                            listElement.insertBefore(placeholder, item);
                            listElement.insertBefore(draggedItem, item);
                        }
                        // Update filesArrayRef here directly by splicing and inserting
                        const draggedFileOriginalIndex = parseInt(draggedItem.dataset.id);
                        const targetFileOriginalIndex = parseInt(item.dataset.id);

                        const draggedFile = filesArrayRef[draggedFileOriginalIndex]; // Assuming filesArrayRef is stable during one drag op

                        // This direct mutation is complex due to shifting indices.
                        // It's often easier to build a new array based on final DOM order in dragend.
                    });

                     item.addEventListener('dragenter', (e) => {
                        e.preventDefault(); // Important for dragover to fire on children
                        if (!draggedItem || draggedItem === item || !item.contains(e.target) ) return;
                        // item.classList.add('drag-over-target'); // visual cue
                    });
                    item.addEventListener('dragleave', (e) => {
                         if (!draggedItem || draggedItem === item || item.contains(e.relatedTarget)) return;
                        // item.classList.remove('drag-over-target');
                    });


                });
                 // Add originalOrderIndex to files for stable reordering IF NOT ALREADY PRESENT
                filesArrayRef.forEach((file, idx) => {
                    if (file.originalOrderIndex === undefined) file.originalOrderIndex = idx;
                });
                listElement.querySelectorAll('.file-item[draggable="true"]').forEach((item, idx) => {
                    // Ensure dataset.id matches the current index in filesArrayRef FOR THIS RENDER
                    // Or better, use a persistent unique ID if files can be added/removed often.
                    // For simplicity now, we assume renderCallback will handle re-assigning dataset.id correctly.
                });
            }


            // --- PDF Splitter ---
            const splitterData = setupFileUpload('splitter');
            const splitterSplitModeEl = document.getElementById('splitterSplitMode');
            document.querySelectorAll('#page-pdf-splitter .splitter-conditional-option').forEach(el => el.style.display='none');
            document.querySelector(`#page-pdf-splitter .splitter-conditional-option[data-mode="ranges"]`).style.display='block';
            splitterSplitModeEl.addEventListener('change', function() {
                document.querySelectorAll('#page-pdf-splitter .splitter-conditional-option').forEach(opt => opt.style.display = 'none');
                const selectedModeDiv = document.querySelector(`#page-pdf-splitter .splitter-conditional-option[data-mode="${this.value}"]`);
                if (selectedModeDiv) selectedModeDiv.style.display = 'block';
            });
            document.getElementById('splitterProcessButton').addEventListener('click', async () => {
                const files = splitterData.getFiles();
                if (files.length === 0) return alert("Please upload a PDF.");
                showLoading(true);
                document.getElementById('splitterResultArea').style.display = 'none'; // Hide previous results
                try {
                    const pdfFile = files[0];
                    const existingPdfBytes = await readFileAsArrayBuffer(pdfFile);
                    const pdfDoc = await PDFDocument.load(existingPdfBytes);
                    const mode = splitterSplitModeEl.value;
                    const totalPages = pdfDoc.getPageCount();
                    let pagesToCopyIndices = [];
                    let baseOutputName = pdfFile.name.replace(/\.pdf$/i, '');

                    if (mode === 'ranges') {
                        const rangesStr = document.getElementById('splitterPageRanges').value.trim();
                        if (!rangesStr) throw new Error("Please enter page ranges.");
                        rangesStr.split(',').forEach(rangePart => {
                            const part = rangePart.trim();
                            if (part.includes('-')) {
                                const [start, end] = part.split('-').map(n => parseInt(n.trim()));
                                if (isNaN(start) || isNaN(end) || start < 1 || end > totalPages || start > end) throw new Error(`Invalid range: ${part}. Max pages: ${totalPages}`);
                                for (let i = start; i <= end; i++) pagesToCopyIndices.push(i - 1);
                            } else {
                                const pageNum = parseInt(part);
                                if (isNaN(pageNum) || pageNum < 1 || pageNum > totalPages) throw new Error(`Invalid page number: ${part}. Max pages: ${totalPages}`);
                                pagesToCopyIndices.push(pageNum - 1);
                            }
                        });
                         if (pagesToCopyIndices.length === 0) throw new Error("No pages selected for extraction based on ranges.");
                        pagesToCopyIndices = [...new Set(pagesToCopyIndices)].sort((a,b) => a-b); // Remove duplicates and sort

                        const newPdfDoc = await PDFDocument.create();
                        const copiedPages = await newPdfDoc.copyPages(pdfDoc, pagesToCopyIndices);
                        copiedPages.forEach(page => newPdfDoc.addPage(page));
                        const newPdfBytes = await newPdfDoc.save();
                        showProcessingResult('splitter', `PDF split by range successfully! ${copiedPages.length} pages extracted.`, true, `${baseOutputName}_split_range.pdf`, newPdfBytes);

                    } else if (mode === 'extract_all') {
                        if (totalPages === 0) throw new Error("PDF has no pages to extract.");
                        let successfulExtractions = 0;
                        for (let i = 0; i < totalPages; i++) {
                            const newPdfDoc = await PDFDocument.create();
                            const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [i]);
                            newPdfDoc.addPage(copiedPage);
                            const newPdfBytes = await newPdfDoc.save();
                            triggerDownload(newPdfBytes, `${baseOutputName}_page_${i+1}.pdf`); // Direct download for multiple files
                            successfulExtractions++;
                            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay for multiple downloads
                        }
                        showProcessingResult('splitter', `All ${successfulExtractions} pages extracted as separate PDFs. Downloads initiated.`, true);
                        document.getElementById('splitterDownloadButton').style.display = 'none'; // No single download button for this mode

                    } else if (mode === 'every_x_pages' || mode === 'fixed_ranges') {
                        const x = parseInt(mode === 'every_x_pages' ? document.getElementById('splitterEveryXPages').value : document.getElementById('splitterFixedRangeSize').value);
                        if (isNaN(x) || x < 1) throw new Error("Invalid number for page splitting.");
                        let successfulSplits = 0;
                        for (let i = 0; i < totalPages; i += x) {
                            const newPdfDoc = await PDFDocument.create();
                            const endIndex = Math.min(i + x, totalPages);
                            const currentBatchIndices = Array.from({length: endIndex - i}, (_, k) => i + k);
                            if (currentBatchIndices.length === 0) continue;

                            const copiedPages = await newPdfDoc.copyPages(pdfDoc, currentBatchIndices);
                            copiedPages.forEach(page => newPdfDoc.addPage(page));
                            const newPdfBytes = await newPdfDoc.save();
                            triggerDownload(newPdfBytes, `${baseOutputName}_split_${Math.floor(i/x)+1}.pdf`); // Direct download
                            successfulSplits++;
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                         showProcessingResult('splitter', `PDF split into ${successfulSplits} files. Downloads initiated.`, true);
                         document.getElementById('splitterDownloadButton').style.display = 'none'; // No single download button
                    }

                } catch (err) {
                    console.error("Splitting Error:", err);
                    showProcessingResult('splitter', `Error splitting PDF: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });

            // --- PDF Merger ---
            const mergerData = setupFileUpload('merger', true);
            document.getElementById('mergerProcessButton').addEventListener('click', async () => {
                const files = mergerData.getFiles();
                if (files.length < 1) return alert("Please upload at least one PDF to merge."); // Technically 1 PDF can be "merged" to itself or renamed.
                showLoading(true);
                document.getElementById('mergerResultArea').style.display = 'none';
                try {
                    const mergedPdf = await PDFDocument.create();
                    for (const file of files) {
                        const pdfBytes = await readFileAsArrayBuffer(file);
                        const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                        const copiedPages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
                        copiedPages.forEach((page) => mergedPdf.addPage(page));
                    }
                    const mergedPdfBytes = await mergedPdf.save();
                    let outputName = document.getElementById('mergerOutputFileName').value.trim() || 'merged_document.pdf';
                    if (!outputName.toLowerCase().endsWith('.pdf')) outputName += '.pdf';
                    showProcessingResult('merger', 'PDFs merged successfully!', true, outputName, mergedPdfBytes);
                } catch (err) {
                    console.error("Merging Error:", err);
                    showProcessingResult('merger', `Error merging PDFs: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });

            // --- Image to PDF ---
            const imageToPdfData = setupFileUpload('imageToPdf', true, "image/jpeg,image/png");
            document.getElementById('imageToPdfProcessButton').addEventListener('click', async () => {
                const files = imageToPdfData.getFiles();
                if (files.length === 0) return alert("Please upload at least one image (JPG or PNG).");
                showLoading(true);
                document.getElementById('imageToPdfResultArea').style.display = 'none';
                try {
                    const newPdfDoc = await PDFDocument.create();
                    const pageSizeOption = document.getElementById('imageToPdfPageSize').value;
                    const margin = parseInt(document.getElementById('imageToPdfMargin').value) || 0;
                    const outputMode = document.getElementById('imageToPdfOutputMode').value; // Currently only 'merge'

                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const imageBytes = await readFileAsArrayBuffer(file);
                        let image;
                        if (file.type === 'image/jpeg') {
                            image = await newPdfDoc.embedJpg(imageBytes);
                        } else if (file.type === 'image/png') {
                            image = await newPdfDoc.embedPng(imageBytes);
                        } else {
                            console.warn(`Unsupported image type skipped: ${file.name}`);
                            continue;
                        }

                        let pageWidth, pageHeight;
                        if (pageSizeOption === 'A4') {
                            [pageWidth, pageHeight] = PageSizes.A4;
                        } else if (pageSizeOption === 'Letter') {
                            [pageWidth, pageHeight] = PageSizes.Letter;
                        } else { // 'image_size'
                            // Use first image's dimensions for all pages if fixed, or each image's own for dynamic
                            // For simplicity, let's use the first image's for all if 'image_size'
                            if (i === 0 || !newPdfDoc.getPage(0)) { // if first image or no page yet
                                pageWidth = image.width + 2 * margin;
                                pageHeight = image.height + 2 * margin;
                            } else {
                                const firstPage = newPdfDoc.getPage(0); // This logic is a bit off if pages vary
                                pageWidth = firstPage.getWidth();       // For now, 'image_size' will use first image's size for all
                                pageHeight = firstPage.getHeight();
                            }
                        }
                        
                        const page = newPdfDoc.addPage([pageWidth, pageHeight]);
                        const { width: imgWidth, height: imgHeight } = image.scaleToFit(page.getWidth() - 2 * margin, page.getHeight() - 2 * margin);
                        
                        page.drawImage(image, {
                            x: page.getWidth() / 2 - imgWidth / 2,
                            y: page.getHeight() / 2 - imgHeight / 2,
                            width: imgWidth,
                            height: imgHeight,
                        });
                    }

                    if (newPdfDoc.getPageCount() === 0) {
                        throw new Error("No valid images were processed to create a PDF.");
                    }

                    const pdfBytes = await newPdfDoc.save();
                    let outputName = document.getElementById('imageToPdfOutputFileName').value.trim() || 'images_converted.pdf';
                    if (!outputName.toLowerCase().endsWith('.pdf')) outputName += '.pdf';
                    showProcessingResult('imageToPdf', 'Images converted to PDF successfully!', true, outputName, pdfBytes);

                } catch (err) {
                    console.error("Image to PDF Error:", err);
                    showProcessingResult('imageToPdf', `Error converting images: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });

            // --- Text to PDF ---
            const textToPdfData = setupFileUpload('textToPdf', false, ".txt"); // Allow one .txt file
            document.getElementById('textToPdfProcessButton').addEventListener('click', async () => {
                showLoading(true);
                document.getElementById('textToPdfResultArea').style.display = 'none';
                try {
                    const textFiles = textToPdfData.getFiles();
                    const textAreaContent = document.getElementById('textToPdfTextArea').value;
                    let textContent = "";

                    if (textFiles.length > 0) {
                        const file = textFiles[0];
                        textContent = await file.text(); // Read .txt file as text
                    } else if (textAreaContent.trim() !== "") {
                        textContent = textAreaContent;
                    } else {
                        throw new Error("No text input provided. Upload a .txt file or enter text in the area.");
                    }

                    const pdfDoc = await PDFDocument.create();
                    const pageSizeKey = document.getElementById('textToPdfPageSizeCmb').value; // A4 or Letter
                    const selectedPageSize = PageSizes[pageSizeKey];
                    const fontKey = document.getElementById('textToPdfFont').value;
                    let pdfFont;
                    if (fontKey === 'Helvetica') pdfFont = StandardFonts.Helvetica;
                    else if (fontKey === 'TimesRoman') pdfFont = StandardFonts.TimesRoman;
                    else pdfFont = StandardFonts.Courier;
                    const embeddedFont = await pdfDoc.embedFont(pdfFont);

                    const fontSize = parseInt(document.getElementById('textToPdfFontSize').value) || 12;
                    const margin = parseInt(document.getElementById('textToPdfMarginInput').value) || 50;
                    
                    const page = pdfDoc.addPage(selectedPageSize);
                    const { width, height } = page.getSize();
                    const usableWidth = width - 2 * margin;
                    const usableHeight = height - 2 * margin;
                    let y = height - margin - fontSize; // Start from top

                    const lines = textContent.split('\n');
                    for (const line of lines) {
                        let currentLine = line;
                        while(currentLine.length > 0) {
                            let textFits = currentLine;
                            let textWidth = embeddedFont.widthOfTextAtSize(textFits, fontSize);
                            while(textWidth > usableWidth) {
                                textFits = textFits.slice(0, -1);
                                textWidth = embeddedFont.widthOfTextAtSize(textFits, fontSize);
                            }
                            
                            if (y < margin + fontSize) { // Need new page
                                page = pdfDoc.addPage(selectedPageSize);
                                y = height - margin - fontSize;
                            }
                            page.drawText(textFits, { x: margin, y: y, font: embeddedFont, size: fontSize, color: rgb(0,0,0) });
                            y -= fontSize * 1.2; // Line height
                            currentLine = currentLine.substring(textFits.length);
                        }
                    }
                    
                    const pdfBytes = await pdfDoc.save();
                    let outputName = document.getElementById('textToPdfOutputFileName').value.trim() || 'text_document.pdf';
                    if (!outputName.toLowerCase().endsWith('.pdf')) outputName += '.pdf';
                    showProcessingResult('textToPdf', 'Text converted to PDF successfully!', true, outputName, pdfBytes);

                } catch (err) {
                    console.error("Text to PDF Error:", err);
                    showProcessingResult('textToPdf', `Error converting text: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });
             // Trigger UI update for TextToPDF options if textarea has content on load (e.g. browser cache)
            const textToPdfTextAreaInit = document.getElementById('textToPdfTextArea');
            if (textToPdfTextAreaInit && textToPdfTextAreaInit.value.trim().length > 0) {
                if (document.getElementById('textToPdfOptions')) document.getElementById('textToPdfOptions').style.display = 'block';
                if (document.getElementById('textToPdfActionButtons')) document.getElementById('textToPdfActionButtons').style.display = 'flex';
            }


            // --- PDF Compressor (Basic Optimization) ---
            const compressorData = setupFileUpload('compressor');
            document.getElementById('compressorProcessButton').addEventListener('click', async () => {
                const files = compressorData.getFiles();
                if (files.length === 0) return alert("Please upload a PDF.");
                showLoading(true);
                document.getElementById('compressorResultArea').style.display = 'none';
                try {
                    const pdfFile = files[0];
                    const existingPdfBytes = await readFileAsArrayBuffer(pdfFile);
                    const pdfDoc = await PDFDocument.load(existingPdfBytes, { updateMetadata: false });
                    const newPdfBytes = await pdfDoc.save({ useObjectStreams: true });
                    let outputName = `${pdfFile.name.replace(/\.pdf$/i, '')}_optimized.pdf`;
                    showProcessingResult('compressor', 'PDF optimized successfully!', true, outputName, newPdfBytes);
                } catch (err) {
                    console.error("Optimization Error:", err);
                     showProcessingResult('compressor', `Error optimizing PDF: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });

            // --- Extract Text (using PDF.js) ---
            const extractData = setupFileUpload('extract');
            const extractedTextOutputEl = document.getElementById('extractedTextOutput');
            const extractResultContainerEl = document.getElementById('extractResultContainer');
            document.getElementById('extractProcessButton').addEventListener('click', async () => {
                const files = extractData.getFiles();
                if (files.length === 0) return alert("Please upload a PDF.");
                showLoading(true);
                document.getElementById('extractResultArea').style.display = 'none'; // Clear previous messages
                extractedTextOutputEl.value = ""; // Clear previous text
                extractResultContainerEl.style.display = 'none'; // Hide result container initially
                try {
                    const file = files[0];
                    const arrayBuffer = await readFileAsArrayBuffer(file);
                    const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                    const pdf = await loadingTask.promise;
                    let fullText = '';
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        textContent.items.forEach(item => fullText += item.str + (item.hasEOL ? "\n" : " "));
                        if (pdf.numPages > 1 && i < pdf.numPages) fullText += "\n\n--- Page Break ---\n\n";
                    }
                    extractedTextOutputEl.value = fullText.trim();
                    extractResultContainerEl.style.display = 'block';
                    showProcessingResult('extract', "Text extraction complete!", true); // General success message
                } catch (err) {
                    console.error("Text Extraction Error:", err);
                    showProcessingResult('extract', `Error extracting text: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });
            document.getElementById('copyExtractedTextButton').addEventListener('click', () => {
                if(extractedTextOutputEl.value){
                    extractedTextOutputEl.select();
                    try {
                        document.execCommand('copy'); // Deprecated but common fallback
                        alert('Text copied to clipboard!');
                    } catch (e) {
                        navigator.clipboard.writeText(extractedTextOutputEl.value).then(() => {
                             alert('Text copied to clipboard!');
                        }).catch(err => {
                            alert('Failed to copy text. Please copy manually.');
                            console.error('Copy failed:', err);
                        });
                    }
                } else {
                    alert('Nothing to copy!');
                }
            });


            // --- Combine PDFs & Images ---
            const combineData = setupFileUpload('combine', true, ".pdf,.jpg,.jpeg,.png");
            document.getElementById('combineProcessButton').addEventListener('click', async () => {
                const files = combineData.getFiles();
                if (files.length < 1) return alert("Please upload files to combine.");
                showLoading(true);
                document.getElementById('combineResultArea').style.display = 'none';
                try {
                    const newPdfDoc = await PDFDocument.create();
                    for (const file of files) {
                        const fileBytes = await readFileAsArrayBuffer(file);
                        if (file.type === 'application/pdf') {
                            const pdfToMerge = await PDFDocument.load(fileBytes, { ignoreEncryption: true });
                            const pageIndices = pdfToMerge.getPageIndices();
                            const copiedPages = await newPdfDoc.copyPages(pdfToMerge, pageIndices);
                            copiedPages.forEach(page => newPdfDoc.addPage(page));
                        } else if (file.type.startsWith('image/')) {
                            let image;
                            if (file.type === 'image/jpeg') image = await newPdfDoc.embedJpg(fileBytes);
                            else if (file.type === 'image/png') image = await newPdfDoc.embedPng(fileBytes);
                            else { console.warn(`Unsupported image type skipped: ${file.name}`); continue; }
                            
                            const page = newPdfDoc.addPage(PageSizes.A4); // Default A4, or use image dims
                            const { width, height } = image.scaleToFit(page.getWidth() - 100, page.getHeight() - 100); // Scale with 50pt margin
                            page.drawImage(image, {
                                x: page.getWidth() / 2 - width / 2,
                                y: page.getHeight() / 2 - height / 2,
                                width, height,
                            });
                        }
                    }
                    if (newPdfDoc.getPageCount() === 0) throw new Error("No processable files were found.");
                    const newPdfBytes = await newPdfDoc.save();
                    let outputName = document.getElementById('combineOutputFileName').value.trim() || 'combined_output.pdf';
                    if (!outputName.toLowerCase().endsWith('.pdf')) outputName += '.pdf';
                    showProcessingResult('combine', 'Files combined successfully!', true, outputName, newPdfBytes);
                } catch (err) {
                    console.error("Combine Error:", err);
                    showProcessingResult('combine', `Error combining files: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });

            // --- Organize PDF Pages ---
            const organizeData = setupFileUpload('organize');
            const organizeFileInputEl = document.getElementById('organizeFileInput');
            const organizeUploadAreaEl = document.getElementById('organizeUploadArea');
            const organizePagePreviewAreaEl = document.getElementById('organizePagePreviewArea');
            const organizePageListEl = document.getElementById('organizePageList');
            let organizePdfDoc = null;
            let organizePageObjects = []; // Stores { originalIndex: 0, id: uniqueId }

            function displayOrganizePages() {
                organizePageListEl.innerHTML = '';
                // organizePageObjects is already ordered by drag and drop
                organizePageObjects.forEach((pageObj, displayIndex) => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('file-item'); // Reusing file-item style
                    listItem.setAttribute('draggable', 'true');
                    listItem.dataset.id = pageObj.id; // Use unique ID for stable drag/drop reference
                    listItem.dataset.originalIndex = pageObj.originalIndex; // Keep for reference

                    listItem.innerHTML = `
                        <i class="fas fa-grip-vertical drag-handle" title="Drag to reorder"></i>
                        <span class="file-name">Page ${pageObj.originalIndex + 1} (New: ${displayIndex + 1})</span>
                        <span class="file-actions">
                            <button class="remove-btn organize-delete-page" title="Delete Page" data-id="${pageObj.id}"><i class="fas fa-trash-alt"></i></button>
                        </span>`;
                    organizePageListEl.appendChild(listItem);
                });

                addDragReorderListenersForOrganize(organizePageListEl, organizePageObjects, displayOrganizePages);

                organizePageListEl.querySelectorAll('.organize-delete-page').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const idToRemove = this.dataset.id;
                        organizePageObjects = organizePageObjects.filter(p => p.id !== idToRemove);
                        displayOrganizePages(); // Re-render
                    });
                });
                organizePagePreviewAreaEl.style.display = organizePageObjects.length > 0 ? 'block' : 'none';
                document.getElementById('organizeActionButtons').style.display = organizePageObjects.length > 0 ? 'flex' : 'none';
                document.getElementById('organizeResultArea').style.display = 'none';
            }
            
            function addDragReorderListenersForOrganize(listElement, pageObjectsArray, renderCallback) {
                let draggedItemEl = null;
                listElement.querySelectorAll('.file-item[draggable="true"]').forEach(itemEl => {
                    itemEl.addEventListener('dragstart', (e) => {
                        draggedItemEl = itemEl;
                        setTimeout(() => itemEl.classList.add('dragging'), 0);
                        e.dataTransfer.effectAllowed = 'move';
                    });
                    itemEl.addEventListener('dragend', () => {
                        if (!draggedItemEl) return;
                        draggedItemEl.classList.remove('dragging');
                        draggedItemEl = null;
                        
                        // Update pageObjectsArray based on new DOM order
                        const newOrderIds = Array.from(listElement.children)
                                               .filter(child => child.classList.contains('file-item'))
                                               .map(child => child.dataset.id);
                        pageObjectsArray.sort((a, b) => newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id));
                        renderCallback();
                    });
                    itemEl.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (!draggedItemEl || draggedItemEl === itemEl) return;
                        e.dataTransfer.dropEffect = 'move';
                        const rect = itemEl.getBoundingClientRect();
                        const isAfter = e.clientY > rect.top + rect.height / 2;
                        if (isAfter) {
                            listElement.insertBefore(draggedItemEl, itemEl.nextSibling);
                        } else {
                            listElement.insertBefore(draggedItemEl, itemEl);
                        }
                    });
                });
            }


            organizeFileInputEl.addEventListener('change', async function(e) {
                if (e.target.files && e.target.files[0]) {
                    showLoading(true);
                    organizeData.resetTool(); // Resets generic parts
                    organizeUploadAreaEl.style.display = 'none'; // Explicitly hide here
                    try {
                        const file = e.target.files[0];
                        const existingPdfBytes = await readFileAsArrayBuffer(file);
                        organizePdfDoc = await PDFDocument.load(existingPdfBytes, { ignoreEncryption: true });
                        organizePageObjects = organizePdfDoc.getPageIndices().map((idx, order) => ({
                            originalIndex: idx,
                            id: `page-${idx}-${Date.now()}` // Unique ID for each page item
                        }));
                        displayOrganizePages();
                         // Manually ensure options/actions are shown as file is "uploaded"
                        document.getElementById('organizeActionButtons').style.display = 'flex';
                        organizePagePreviewAreaEl.style.display = 'block';


                    } catch (err) {
                        alert("Error loading PDF for organization: " + err.message);
                        organizeUploadAreaEl.style.display = 'block';
                    } finally { showLoading(false); }
                }
            });
            document.getElementById('organizeProcessButton').addEventListener('click', async () => {
                if (!organizePdfDoc || organizePageObjects.length === 0 && organizePdfDoc.getPageCount() > 0) {
                     // If all pages deleted from a previously non-empty PDF
                    if (organizePdfDoc && organizePdfDoc.getPageCount() > 0 && organizePageObjects.length === 0) {
                         if (!confirm("All pages have been marked for deletion. This will create an empty PDF. Continue?")) {
                            return;
                         }
                    } else {
                        alert("No PDF loaded or no pages to organize.");
                        return;
                    }
                }
                showLoading(true);
                document.getElementById('organizeResultArea').style.display = 'none';
                try {
                    const newPdfDoc = await PDFDocument.create();
                    const finalPageIndicesToCopy = organizePageObjects.map(p => p.originalIndex);

                    if (finalPageIndicesToCopy.length > 0) {
                        const copiedPages = await newPdfDoc.copyPages(organizePdfDoc, finalPageIndicesToCopy);
                        copiedPages.forEach(page => newPdfDoc.addPage(page));
                    } else {
                        // Create an empty PDF if all pages were deleted
                        newPdfDoc.addPage(); // Add a blank page to make it a valid PDF
                    }
                    const newPdfBytes = await newPdfDoc.save();
                    const originalFileName = organizeFileInputEl.files[0] ? organizeFileInputEl.files[0].name : 'document.pdf';
                    showProcessingResult('organize', 'PDF organized successfully!', true, `organized_${originalFileName.replace(/\.pdf$/i, '')}.pdf`, newPdfBytes);
                } catch (err) {
                    console.error("Organize Error:", err);
                    showProcessingResult('organize', `Error saving organized PDF: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });


            // --- Password Lock PDF ---
            const lockData = setupFileUpload('lock');
            document.getElementById('lockProcessButton').addEventListener('click', async () => {
                const files = lockData.getFiles();
                if (files.length === 0) return alert("Please upload a PDF.");
                const userPassword = document.getElementById('lockUserPassword').value;
                const ownerPassword = document.getElementById('lockOwnerPassword').value;

                if (!userPassword && !ownerPassword) return alert("Please set at least one password (user or owner).");
                showLoading(true);
                document.getElementById('lockResultArea').style.display = 'none';
                try {
                    const pdfFile = files[0];
                    const existingPdfBytes = await readFileAsArrayBuffer(pdfFile);
                    const pdfDoc = await PDFDocument.load(existingPdfBytes, {ignoreEncryption: true}); // Load, ignoring if already encrypted

                    const permissions = {
                        printing: document.getElementById('permPrinting').checked,
                        modifying: document.getElementById('permModifying').checked,
                        copying: document.getElementById('permCopying').checked,
                        annotating: document.getElementById('permAnnotations').checked,
                    };
                    const options = {};
                    if (userPassword) options.userPassword = userPassword;
                    if (ownerPassword) {
                         options.ownerPassword = ownerPassword;
                         options.permissions = permissions;
                    } else if (userPassword && !ownerPassword) { // If only user pass, default owner permissions (allow all)
                        options.permissions = { printing: true, modifying: true, copying: true, annotating: true};
                    }


                    const newPdfBytes = await pdfDoc.save(options);
                    showProcessingResult('lock', 'PDF locked successfully!', true, `${pdfFile.name.replace(/\.pdf$/i, '')}_locked.pdf`, newPdfBytes);
                } catch (err) {
                    console.error("Lock Error:", err);
                    showProcessingResult('lock', `Error locking PDF: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });

            // --- Remove PDF Password (Unlock) ---
            const unlockData = setupFileUpload('unlock');
            document.getElementById('unlockProcessButton').addEventListener('click', async () => {
                const files = unlockData.getFiles();
                if (files.length === 0) return alert("Please upload a PDF.");
                const userPassword = document.getElementById('unlockUserPassword').value;
                const ownerPassword = document.getElementById('unlockOwnerPassword').value;
                showLoading(true);
                document.getElementById('unlockResultArea').style.display = 'none';
                try {
                    const pdfFile = files[0];
                    const existingPdfBytes = await readFileAsArrayBuffer(pdfFile);
                    const loadOptions = { ignoreEncryption: false }; // Default: try to respect encryption
                    if (userPassword) loadOptions.password = userPassword;
                    else if (ownerPassword) loadOptions.password = ownerPassword;
                    // if no password provided, and file is encrypted, load will fail.
                    // if file is not encrypted, it will load fine.

                    let pdfDoc;
                    try {
                        pdfDoc = await PDFDocument.load(existingPdfBytes, loadOptions);
                    } catch (loadErr) {
                        // If loading with provided password fails, or if no password and it's encrypted
                        // Try loading with ignoreEncryption as a fallback to see if it's just not encrypted
                        if (loadErr.message.toLowerCase().includes('encrypted') && (userPassword || ownerPassword)) {
                             throw new Error(`Failed to unlock with the provided password. ${loadErr.message}`);
                        }
                        try {
                            pdfDoc = await PDFDocument.load(existingPdfBytes, { ignoreEncryption: true });
                            // If this succeeds, it means the PDF wasn't actually encrypted or the provided password was not for standard encryption.
                            // We can just re-save it.
                        } catch (finalLoadErr) {
                            throw new Error(`Could not load PDF. It might be corrupted or heavily encrypted. ${finalLoadErr.message}`);
                        }
                    }

                    // Simply save it without any password options to remove them
                    const newPdfBytes = await pdfDoc.save();
                    showProcessingResult('unlock', 'PDF unlocked and restrictions removed successfully!', true, `${pdfFile.name.replace(/\.pdf$/i, '')}_unlocked.pdf`, newPdfBytes);
                } catch (err) {
                    console.error("Unlock Error:", err);
                    showProcessingResult('unlock', `Error unlocking PDF: ${err.message}.`, false);
                } finally {
                    showLoading(false);
                }
            });

            // --- Add Watermark to PDF ---
            const watermarkData = setupFileUpload('watermark');
            const watermarkTypeEl = document.getElementById('watermarkType');
            const watermarkTextGroupEl = document.getElementById('watermarkTextGroup');
            const watermarkImageGroupEl = document.getElementById('watermarkImageGroup');
            watermarkTypeEl.addEventListener('change', function() {
                watermarkTextGroupEl.style.display = this.value === 'text' ? 'block' : 'none';
                watermarkImageGroupEl.style.display = this.value === 'image' ? 'block' : 'none';
            });
            watermarkTypeEl.dispatchEvent(new Event('change')); // Init visibility
            document.getElementById('watermarkProcessButton').addEventListener('click', async () => {
                const files = watermarkData.getFiles();
                if (files.length === 0) return alert("Please upload a PDF.");
                showLoading(true);
                document.getElementById('watermarkResultArea').style.display = 'none';
                try {
                    const pdfFile = files[0];
                    const existingPdfBytes = await readFileAsArrayBuffer(pdfFile);
                    const pdfDoc = await PDFDocument.load(existingPdfBytes, { ignoreEncryption: true });
                    const pages = pdfDoc.getPages();
                    const type = watermarkTypeEl.value;
                    const opacity = parseFloat(document.getElementById('watermarkOpacity').value);
                    const rotationDegreesVal = parseInt(document.getElementById('watermarkRotation').value);
                    const position = document.getElementById('watermarkPosition').value;


                    if (type === 'text') {
                        const text = document.getElementById('watermarkText').value;
                        if (!text) throw new Error("Watermark text cannot be empty.");
                        const fontSize = parseInt(document.getElementById('watermarkFontSize').value);
                        const colorStr = document.getElementById('watermarkColor').value;
                        const color = rgb( parseInt(colorStr.slice(1,3),16)/255, parseInt(colorStr.slice(3,5),16)/255, parseInt(colorStr.slice(5,7),16)/255 );
                        const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold); // Or allow font choice

                        for (const page of pages) {
                            const { width, height } = page.getSize();
                            const textWidth = font.widthOfTextAtSize(text, fontSize);
                            const textHeight = font.heightAtSize(fontSize); // Approx height

                            if (position === 'tile') {
                                // Simple tiling logic (can be improved for better coverage/overlap)
                                const xStep = textWidth * 1.5 + 100; // Add more spacing for tiling
                                const yStep = textHeight * 3 + 100;
                                for (let x = -textWidth; x < width + textWidth; x += xStep) {
                                    for (let y = -textHeight; y < height + textHeight; y += yStep) {
                                        page.drawText(text, { x, y, font, size: fontSize, color, opacity, rotate: degrees(rotationDegreesVal) });
                                    }
                                }
                            } else {
                                let x, y;
                                if (position === 'center') { x = width/2 - textWidth/2; y = height/2 - textHeight/3; } // Adjusted for better visual center
                                else if (position === 'top_left') { x = 20; y = height - 20 - textHeight; }
                                else if (position === 'top_right') { x = width - 20 - textWidth; y = height - 20 - textHeight; }
                                else if (position === 'bottom_left') { x = 20; y = 20; }
                                else if (position === 'bottom_right') { x = width - 20 - textWidth; y = 20; }
                                page.drawText(text, { x, y, font, size: fontSize, color, opacity, rotate: degrees(rotationDegreesVal) });
                            }
                        }
                    } else if (type === 'image') {
                        const imageFile = document.getElementById('watermarkImageFile').files[0];
                        if (!imageFile) throw new Error("Please select a watermark image.");
                        const imageBytes = await readFileAsArrayBuffer(imageFile);
                        let embeddedImage;
                        if (imageFile.type === 'image/png') embeddedImage = await pdfDoc.embedPng(imageBytes);
                        else if (imageFile.type === 'image/jpeg') embeddedImage = await pdfDoc.embedJpg(imageBytes);
                        else throw new Error("Unsupported watermark image type. Use PNG or JPG.");

                        const scale = parseFloat(document.getElementById('watermarkScale').value) || 0.5;
                        const imgDims = embeddedImage.scale(scale);

                        for (const page of pages) {
                             const { width, height } = page.getSize();
                             if (position === 'tile') {
                                const xStep = imgDims.width * 1.2;
                                const yStep = imgDims.height * 1.2;
                                for (let x = 0; x < width; x += xStep) {
                                    for (let y = 0; y < height; y += yStep) {
                                        page.drawImage(embeddedImage, { x, y, width: imgDims.width, height: imgDims.height, opacity, rotate: degrees(rotationDegreesVal) });
                                    }
                                }
                             } else {
                                let x,y;
                                if (position === 'center') { x = width/2 - imgDims.width/2; y = height/2 - imgDims.height/2; }
                                else if (position === 'top_left') { x = 20; y = height - 20 - imgDims.height; }
                                else if (position === 'top_right') { x = width - 20 - imgDims.width; y = height - 20 - imgDims.height; }
                                else if (position === 'bottom_left') { x = 20; y = 20; }
                                else if (position === 'bottom_right') { x = width - 20 - imgDims.width; y = 20; }
                                page.drawImage(embeddedImage, { x, y, width: imgDims.width, height: imgDims.height, opacity, rotate: degrees(rotationDegreesVal) });
                             }
                        }
                    }
                    const newPdfBytes = await pdfDoc.save();
                    showProcessingResult('watermark', 'Watermark added successfully!', true, `${pdfFile.name.replace(/\.pdf$/i, '')}_watermarked.pdf`, newPdfBytes);
                } catch (err) {
                    console.error("Watermark Error:", err);
                    showProcessingResult('watermark', `Error adding watermark: ${err.message}`, false);
                } finally {
                    showLoading(false);
                }
            });

            // Initialize first page
            showPage('page-dashboard');
        });
    </script>
</body>
</html>